import sys
import os.path
import time

from compiler.tokenizer import Tokenizer
from compiler.ast import ASTParser
from compiler.type_checker import TypeChecker
from compiler.assembler import Assembler
from compiler.instructions import Instruction

def compile(source, debug=False, filename="main.hatch"):
    tokenizer = Tokenizer(source, filename)
    tokens = tokenizer.tokenize()

    ast = ASTParser(tokens, compiler=[compile, compile_file], main_file=filename)
    tree, sub_trees, error = ast.parse()

    if error:
        sys.exit()
    
    if debug:
        for trunk in tree:
            trunk.print()
        print()
            
    type_checker = TypeChecker(source, tree, sub_trees)
    called_function_names = type_checker.check()

    def add_trees(tree, sub_trees):
        tree = list(tree)
        for name, st in sub_trees.items():
            tree += add_trees(*st)
        return tree

    all_functions = add_trees(tree, sub_trees)

    for function in all_functions:
        function.optimise()

    if debug:
        print("------------------------\nOptimised tree:\n")
        for trunk in tree:
            trunk.print()
        print()
        
    assembler = Assembler(tree, sub_trees, called_function_names)
    instructions, addresses, data_start = assembler.assemble()
    if debug:
        return instructions, addresses, data_start
    return instructions

def compile_file(filename, debug):
    filename = os.path.abspath(filename)
    with open(filename, "r") as source_file:
        source = source_file.read()
    return compile(source, debug=debug, filename=filename)

if __name__ == "__main__":
    start_time = time.perf_counter()
    instructions, addresses, data_start = compile_file("testfile.hatch", True)
    
    if len(instructions) > 240:
        time.sleep(0.05)
        raise Exception(f"Compiled binary will not fit in memory, size: {len(instructions)} bytes")
    if not all([isinstance(inst, int) for inst in instructions]):
        print(instructions)
        raise Exception("Not all instructions were ints")
    if not all([(0 <= inst <= 255) for inst in instructions]):
        raise Exception("Overflowed value in output instructions")
    
    try:
        with open("testfile.hb", "wb") as output_file:
            output_file.write(bytes(instructions))
    except TypeError:
        print("Could not write output")
        print("Instructions: ", instructions)
        raise Exception
    
    with open("testfile.hasm", "w") as output_file:
        output_file.write("; autogenerated assembly\n")
        #output_file.writelines(map(lambda x: str(bin(x)[2:]).zfill(8) + "\n", instructions))
        for i, (op, data) in enumerate(zip(instructions[:data_start:2], instructions[1:data_start:2])):
            for name, location in addresses.items():
                if i*2 == location:
                    if isinstance(name, tuple):
                        output_file.write(f"{'.'.join(name)}:\n")
                    elif isinstance(name, str):
                        output_file.write(f"{name}:\n")
            surround1, surround2 = "", ""
            if op & 0b11000000 == 0b11000000:
                surround1, surround2 = "[$", "]"
            elif op & 0b10000000 == 0b10000000:
                surround1, surround2 = "[", "]"
            elif op & 0b01000000 == 0b01000000:
                surround1, surround2 = "$", ""
            output_file.write(f"{i*2}: {Instruction(op&0b11111).name} {surround1}{data}{surround2}\n")
        output_file.write("data:\n")
        for index, byte in enumerate(instructions[data_start:], start=data_start):
            output_file.write(f"{index}: {byte}\n")
        
    
    duration = time.perf_counter()-start_time
    print(f"Compilation complete, filesize={len(instructions)} bytes, time={duration:.04f} seconds")
